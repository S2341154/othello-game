<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ã‚ªã‚»ãƒ­ï¼ˆFirebaseå¯¾å¿œãƒ»å®Œå…¨å®‰å®šç‰ˆï¼‰</title>
<link rel="icon" href="favicon.ico" />
  <style>
    :root{ --board-size: min(640px, 92vw); --bg:#0b3d2e; --control-w:320px; }
    body{ font-family: system-ui, -apple-system, "Hiragino Kaku Gothic ProN", "Noto Sans JP", "Segoe UI", Roboto, "Yu Gothic"; display:flex;gap:18px;align-items:flex-start;justify-content:center;padding:20px;background:#e9f0ed;color:#062; }
    .wrap{display:flex;gap:18px;align-items:flex-start;flex-wrap:wrap;justify-content:center;}
    .board{ width:var(--board-size);height:var(--board-size); background:linear-gradient(#0f523b,#0b3d2e); display:grid; grid-template-columns:repeat(8,1fr); grid-template-rows:repeat(8,1fr); gap:2px; padding:6px; border-radius:12px; box-shadow:0 6px 18px rgba(0,0,0,0.18); position:relative; }
    .cell{ background:var(--bg); border-radius:6px; position:relative; display:flex; align-items:center; justify-content:center; cursor:pointer; user-select:none; overflow:visible; }
    .cell:hover{ box-shadow:inset 0 0 0 2px rgba(255,255,255,0.03) }
    .disc{ width:84%; height:84%; border-radius:50%; box-shadow:inset 0 -6px 12px rgba(0,0,0,0.25); transition:transform 360ms ease; transform-style:preserve-3d; backface-visibility:hidden; }
    .disc.black{ background:linear-gradient(#222,#000) }
    .disc.white{ background:linear-gradient(#fff,#ddd) }
    .disc.flip{ transform:rotateY(180deg) }
    /* new placement animation */
    @keyframes placeDisc {
      0% { transform: scale(0.2); opacity: 0; }
      70% { transform: scale(1.08); opacity: 1; }
      100% { transform: scale(1); }
    }
    .disc.new { animation: placeDisc 280ms ease-out forwards; }

    .legal::after {
      content: '';
      position: absolute;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: rgba(255,255,255,0.9);
      opacity: 0.9;
      box-shadow: 0 1px 4px rgba(0,0,0,0.4);
      transition: transform 0.2s ease;
    }
    .cell.legal:hover::after { transform: scale(1.3); }

    .controls{ min-width:var(--control-w); display:flex; flex-direction:column; gap:10px; }
    .status{ background:#fff; padding:12px; border-radius:8px; box-shadow:0 6px 18px rgba(0,0,0,0.06); }
    .row{ display:flex; justify-content:space-between; gap:8px; align-items:center; }
    button{ padding:8px 12px; border-radius:8px; border:none; background:#0b7a59; color:#fff; font-weight:600; cursor:pointer; }
    button.secondary{ background:#5b5b5b; }
    select,input{ padding:8px; border-radius:6px; border:1px solid #ccc; }
    .small{ font-size:0.9rem; }
    footer{ font-size:0.8rem; color:#346; text-align:center; }
    @media (max-width:720px){ body{ flex-direction:column; align-items:center } .controls{ min-width:90vw } :root{ --board-size:90vw } }
    /* small badge for players count */
    #playersCount { display:inline-block; margin-left:8px; padding:2px 8px; background:#eee; color:#062; border-radius:12px; font-weight:700; font-size:0.85rem; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="board" id="board" aria-label="ã‚ªã‚»ãƒ­ã®ç›¤"></div>

    <div class="controls">
      <div class="status">
        <div class="row"><div>é»’ (â—)</div><div id="score-black">2</div></div>
        <div class="row"><div>ç™½ (â—‹)</div><div id="score-white">2</div></div>
        <hr/>
        <div class="row small"><div>ç¾åœ¨ã®æ‰‹ç•ª</div><div id="turn">é»’</div></div>
        <div class="row small"><div>åˆæ³•æ‰‹æ•°</div><div id="legal-count">4</div></div>
      </div>

      <div class="status">
        <div class="row"><div>ãƒ¢ãƒ¼ãƒ‰</div>
          <select id="modeSelect">
            <option value="cpu">ã‚·ãƒ³ã‚°ãƒ«ãƒ—ãƒ¬ã‚¤ï¼ˆCPUï¼‰</option>
            <option value="local">ãƒ­ãƒ¼ã‚«ãƒ«2äººå¯¾æˆ¦</option>
            <option value="online">ã‚ªãƒ³ãƒ©ã‚¤ãƒ³å¯¾æˆ¦</option>
          </select>
        </div>

        <div id="cpuPanel" style="margin-top:8px">
          <div class="row small"><div>CPUå¼·ã•</div>
            <select id="aiLevel">
              <option value="0">åˆç´šï¼ˆãƒ©ãƒ³ãƒ€ãƒ ï¼‰</option>
              <option value="1" selected>ä¸­ç´šï¼ˆæœ€å¤§åè»¢ï¼‰</option>
              <option value="2">ä¸Šç´šï¼ˆ2æ‰‹èª­ã¿ï¼‰</option>
            </select>
          </div>
          <div class="row small" style="margin-top:6px"><div>ã‚ãªãŸã®è‰²</div>
            <select id="playerColor"><option value="1" selected>é»’ï¼ˆå…ˆæ‰‹ï¼‰</option><option value="2">ç™½ï¼ˆå¾Œæ‰‹ï¼‰</option></select>
          </div>
        </div>

        <div id="onlinePanel" style="display:none;margin-top:10px">
          <div class="row small"><div>ã‚ªãƒ³ãƒ©ã‚¤ãƒ³</div>
            <select id="onlineMode"><option value="off">ã‚ªãƒ•</option><option value="host">éƒ¨å±‹ã‚’ä½œã‚‹</option><option value="join">éƒ¨å±‹ã«å…¥ã‚‹</option></select>
          </div>
          <div id="onlineControls" style="display:none;margin-top:8px">
            <div style="display:flex;gap:8px">
              <input id="roomId" placeholder="éƒ¨å±‹IDï¼ˆè‡ªå‹•ç”Ÿæˆå¯ï¼‰"/>
              <button id="createRoom">ä½œæˆ</button>
              <button id="joinRoom" class="secondary">å‚åŠ </button>
              <button id="deleteRoomBtn" class="secondary" style="display:none">éƒ¨å±‹å‰Šé™¤</button>
            </div>
            <div style="margin-top:6px">
              <div class="small">Realtime DB ã‚’ä½¿ã„ã¾ã™ <span id="playersCount"></span></div>
              <small id="connectionStatus">æœªæ¥ç¶š</small>
            </div>
          </div>
        </div>
      </div>

      <div style="display:flex;gap:8px;flex-wrap:wrap;justify-content:space-between">
        <button id="reset">ãƒªã‚»ãƒƒãƒˆ</button>
        <button id="undo" class="secondary">å–ã‚Šæ¶ˆã—</button>
        <button id="pass" class="secondary">ãƒ‘ã‚¹</button>
      </div>

      <div class="status small">
        <p>èª¬æ˜ï¼šå„ã‚¿ãƒ¼ãƒ³ã”ã¨ã«å„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯1å›ã ã‘å–ã‚Šæ¶ˆã—ã§ãã¾ã™ï¼ˆè‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³å†…ã§ã®ã¿ï¼‰ã€‚ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ã¯ Firebase Realtime Database ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚</p>
      </div>
    </div>
  </div>

  <footer>Firebaseç‰ˆ Othelloï¼ˆå®Œå…¨å®‰å®šç‰ˆï¼‰</footer>

  <script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-app.js";
  import { getDatabase, ref, set, get, onValue, off, update } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-database.js";

  // ãã®ã¾ã¾ä½¿ã† Firebase è¨­å®šï¼ˆã‚ãªãŸãŒæç¤ºã—ãŸã‚‚ã®ï¼‰
  const firebaseConfig = {
    apiKey: "AIzaSyC8x4BmjNJlqMkCbs1xIi_OkNc2Hp3UWbY",
  authDomain: "othello-online-23943.firebaseapp.com",
  databaseURL: "https://othello-online-23943-default-rtdb.firebaseio.com",
  projectId: "othello-online-23943",
  storageBucket: "othello-online-23943.firebasestorage.app",
  messagingSenderId: "700231693409",
  appId: "1:700231693409:web:57c6b500271c80e4d2a620"
  };

  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);
  const FB = { db, ref, set, get, onValue, off, update };

  document.addEventListener("DOMContentLoaded", () => {
    const SIZE = 8;
    const DIRS = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];

    // game state
    let board = initialBoard();
    let turn = 1;
    let history = [];
    let busy = false;
    let undoUsed = {1:false,2:false};

    // firebase room state
    let firebaseRoomId = null;
    let firebasePlayer = null; // 1 or 2
    let isHost = false;
    let fbUnsubscribe = null;

    // UI
    const boardEl = document.getElementById("board");
    const scoreB = document.getElementById("score-black");
    const scoreW = document.getElementById("score-white");
    const turnEl = document.getElementById("turn");
    const legalCountEl = document.getElementById("legal-count");
    const modeSelect = document.getElementById("modeSelect");
    const cpuPanel = document.getElementById("cpuPanel");
    const aiLevelSel = document.getElementById("aiLevel");
    const playerColorSel = document.getElementById("playerColor");
    const onlinePanel = document.getElementById("onlinePanel");
    const onlineModeSel = document.getElementById("onlineMode");
    const onlineControls = document.getElementById("onlineControls");
    const roomInput = document.getElementById("roomId");
    const createBtn = document.getElementById("createRoom");
    const joinBtn = document.getElementById("joinRoom");
    const deleteBtn = document.getElementById("deleteRoomBtn");
    const connectionStatus = document.getElementById("connectionStatus");
    const playersCountEl = document.getElementById("playersCount");
    const resetBtn = document.getElementById("reset");
    const undoBtn = document.getElementById("undo");
    const passBtn = document.getElementById("pass");

    // helpers
    function cloneBoard(b){ return b.map(r=>[...r]); }
    function inside(r,c){ return r>=0 && r<SIZE && c>=0 && c<SIZE; }
    function countScores(b=board){ let bC=0,wC=0; for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++){ if(b[r][c]===1) bC++; else if(b[r][c]===2) wC++; } return {b:bC,w:wC}; }
    function saveState(){ history.push({board:cloneBoard(board),turn}); if(history.length>256) history.shift(); updateUndo(); }
    function updateUndo(){ undoBtn.disabled = (modeSelect.value==="online") || history.length<2 || busy || undoUsed[turn]; }
    function legalMovesFor(p, b=board){
      const opp = p===1?2:1;
      const moves = [];
      for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++){
        if(b[r][c]!==0) continue;
        for(const [dr,dc] of DIRS){
          let rr=r+dr, cc=c+dc, found=false;
          while(inside(rr,cc) && b[rr][cc]===opp){ rr+=dr; cc+=dc; found=true; }
          if(found && inside(rr,cc) && b[rr][cc]===p){ moves.push([r,c]); break; }
        }
      }
      return moves;
    }
    function applyMove(p,r,c,b=board){
      const opp = p===1?2:1;
      if(b[r][c]!==0) return [];
      b[r][c]=p;
      const flipped = [];
      for(const [dr,dc] of DIRS){
        let rr=r+dr, cc=c+dc, path=[];
        while(inside(rr,cc) && b[rr][cc]===opp){ path.push([rr,cc]); rr+=dr; cc+=dc; }
        if(path.length && inside(rr,cc) && b[rr][cc]===p){
          for(const [fr,fc] of path){ b[fr][fc]=p; flipped.push([fr,fc]); }
        }
      }
      return flipped;
    }

    // rendering (keeps look same as before)
    function render(){
      boardEl.innerHTML = '';
      const legal = legalMovesFor(turn);
      const mode = modeSelect.value;
      const isOnline = mode === 'online';
      const isMyTurn = !isOnline || (firebasePlayer === turn);

      // build grid
      for(let r=0;r<SIZE;r++){
        for(let c=0;c<SIZE;c++){
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.dataset.r = r;
          cell.dataset.c = c;

          if(board[r][c] !== 0){
            const d = document.createElement('div');
            d.className = 'disc ' + (board[r][c]===1 ? 'black' : 'white');
            cell.appendChild(d);
          } else {
            // show legal only if local/cpu OR online & myTurn
            if(legal.some(x=>x[0]===r && x[1]===c)){
              if(!isOnline || isMyTurn) cell.classList.add('legal');
            }
          }
          boardEl.appendChild(cell);
        }
      }

      const sc = countScores();
      scoreB.textContent = sc.b;
      scoreW.textContent = sc.w;
      turnEl.textContent = turn===1 ? 'é»’' : 'ç™½';
      legalCountEl.textContent = legal.length;

      // board dimming for online
      if(isOnline){
        boardEl.style.opacity = isMyTurn ? '1' : '0.5';
      } else {
        boardEl.style.opacity = '1';
      }

      // pass button enabled only when no legal moves
      passBtn.disabled = (legal.length > 0) || busy;

      updateUndo();
      // expose few for debugging if needed
      window.turn = turn;
      window.firebasePlayer = firebasePlayer;
    }

    // click handling
    boardEl.addEventListener('click', e=>{
      const cell = e.target.closest('.cell');
      if(!cell || busy) return;
      const r = +cell.dataset.r, c = +cell.dataset.c;
      const mode = modeSelect.value;

      if(mode === 'cpu' || mode === 'local'){
        const legal = legalMovesFor(turn);
        if(!legal.some(x=>x[0]===r && x[1]===c)) return;
        saveState();
        applyMove(turn, r, c);
        // mark new disc for animation: add class new to that disc element after render
        // but we use render to re-create DOM; we can add new class by comparing history last -> handled below by saving state and checking
        turn = 3 - turn;
        undoUsed[turn] = false;
        saveState();
        render();
        if(mode === 'cpu' && turn !== +playerColorSel.value){
          // CPU move schedule: ensure only one scheduled at a time
          setTimeout(doCpu, 300);
        }
      } else if(mode === 'online'){
        if(!firebaseRoomId){ alert('ã‚ªãƒ³ãƒ©ã‚¤ãƒ³æœªæ¥ç¶š'); return; }
        if(firebasePlayer !== turn){ alert('ã‚ãªãŸã®æ‰‹ç•ªã§ã¯ã‚ã‚Šã¾ã›ã‚“'); return; }
        const legal = legalMovesFor(turn);
        if(!legal.some(x=>x[0]===r && x[1]===c)) return;
        // optimistic local apply (but we will sync to DB)
        saveState();
        applyMove(turn, r, c);
        // advance turn locally while syncing DB (DB authoritative will update all clients)
        const nextTurn = 3 - turn;
        // update DB with board and nextTurn, clear lastPass
        setRoomFirebase(firebaseRoomId, board, nextTurn, { lastPass: null });
      }
    });

    // reset / undo / pass
    resetBtn.addEventListener('click', ()=>{
      if(!confirm('ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿ')) return;
      init();
      if(firebaseRoomId && isHost){
        // host should write initial board to DB
        setRoomFirebase(firebaseRoomId, board, 1, { lastPass: null, players: 1 });
      } else if(firebaseRoomId && !isHost){
        // guest: don't overwrite host DB
      }
    });

    undoBtn.addEventListener('click', ()=>{
      if(busy) return;
      if(modeSelect.value === 'online') return;
      if(history.length < 2) return;
      if(undoUsed[turn]) return;
      // pop last (current state), then restore previous
      history.pop();
      const last = history.pop();
      board = cloneBoard(last.board);
      turn = last.turn;
      undoUsed[turn] = true;
      saveState();
      render();
    });

    passBtn.addEventListener('click', async ()=>{
      if(busy) return;
      const legal = legalMovesFor(turn);
      if(legal.length > 0) return; // cannot pass if you have legal moves

      const mode = modeSelect.value;
      if(mode === 'online'){
        if(!firebaseRoomId) return alert('ã‚ªãƒ³ãƒ©ã‚¤ãƒ³æœªæ¥ç¶š');
        if(firebasePlayer !== turn) return alert('ã‚ãªãŸã®æ‰‹ç•ªã§ã¯ã‚ã‚Šã¾ã›ã‚“');
        // set lastPass to current player in DB; if lastPass already other player => both passed => end game
        const roomRef = FB.ref(FB.db, 'rooms/' + firebaseRoomId);
        try {
          // read current data
          const snap = await FB.get(roomRef);
          const data = snap.exists() ? snap.val() : null;
          const prevLastPass = data && data.lastPass ? data.lastPass : null;
          if(prevLastPass && prevLastPass !== firebasePlayer){
            // both passed -> end game
            // leave final board in DB and set finished flag
            await FB.update(roomRef, { lastPass: firebasePlayer, finished: true });
            // show result locally
            setTimeout(()=>{ showGameEndAndReset(); }, 200);
          } else {
            // set lastPass to this player and advance turn
            const nextTurn = 3 - turn;
            await FB.update(roomRef, { lastPass: firebasePlayer, board: board, turn: nextTurn });
          }
        } catch(err){
          console.error('pass error', err);
        }
      } else {
        // offline pass
        turn = 3 - turn;
        undoUsed[turn] = false;
        saveState();
        render();
      }
    });

    // CPU
    function ai_random(p){ const m = legalMovesFor(p); return m.length ? m[Math.floor(Math.random()*m.length)] : null; }
    function ai_maxflip(p){ const m = legalMovesFor(p); let best=null, max=-1; for(const [r,c] of m){ const b = cloneBoard(board); const f = applyMove(p,r,c,b); if(f.length>max){ max=f.length; best=[r,c]; } } return best; }
    function ai_minimax(p){ return ai_maxflip(p); } // simplified

    function doCpu(){
      if(busy) return;
      if(modeSelect.value !== 'cpu') return;
      const cpu = (+playerColorSel.value === 1) ? 2 : 1;
      if(turn !== cpu) return;
      busy = true;
      setTimeout(()=>{
        const lvl = +aiLevelSel.value;
        let mv = null;
        if(lvl === 0) mv = ai_random(cpu);
        else if(lvl === 1) mv = ai_maxflip(cpu);
        else mv = ai_minimax(cpu);
        if(!mv){
          // pass
          turn = 3 - turn;
          undoUsed[turn] = false;
          saveState();
          busy = false;
          render();
          return;
        }
        saveState();
        applyMove(cpu, mv[0], mv[1]);
        turn = 3 - turn;
        undoUsed[turn] = false;
        saveState();
        busy = false;
        render();
      }, 380);
    }

    // Firebase: helper to set room data atomically-ish
    async function setRoomFirebase(room, b, t, extra = {}){
      const r = FB.ref(FB.db, 'rooms/' + room);
      const payload = Object.assign({}, { board: b, turn: t }, extra);
      try {
        await FB.update(r, payload);
      } catch(e){
        console.error('setRoomFirebase error', e);
      }
    }

    // send move (online) -- uses DB update, DB listener will push to other clients
    async function sendMoveFirebase(room, p, rpos, cpos){
      if(busy) return;
      busy = true;
      // validate legal on server copy is omitted (simple implementation)
      // apply locally first for responsiveness
      applyMove(p, rpos, cpos);
      const nextTurn = 3 - p;
      try {
        await setRoomFirebase(room, board, nextTurn, { lastPass: null });
      } catch(e){
        console.error('sendMoveFirebase error', e);
      } finally {
        busy = false;
      }
    }

    // listen to room: register onValue, manage unsubscribe
    function listenRoom(room){
      // detach previous
      if(fbUnsubscribe){
        try { fbUnsubscribe(); } catch(e) {}
        fbUnsubscribe = null;
      }
      const r = FB.ref(FB.db, 'rooms/' + room);

      // subscribe
      const unsub = FB.onValue(r, (snap)=>{
        const data = snap.exists() ? snap.val() : null;
        if(!data){
          // room removed -> exit to local
          alert('ãƒ›ã‚¹ãƒˆãŒéƒ¨å±‹ã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚ãƒ­ãƒ¼ã‚«ãƒ«å¯¾æˆ¦ã«æˆ»ã‚Šã¾ã™ã€‚');
          leaveRoomLocal(true);
          return;
        }
        // update players count display
        const players = data.players || 1;
        playersCountEl.textContent = `(${players}/2)`;

        // if finished flag set -> show result once then reset room locally (do not delete DB)
        if(data.finished){
          // copy board & show result
          if(Array.isArray(data.board)) board = data.board.map(row=>row.map(x=>x||0));
          render();
          setTimeout(()=>{ showGameEndAndReset(); }, 200);
          return;
        }

        // normal update: apply board & turn
        if(Array.isArray(data.board)){
          board = data.board.map(row=>row.map(x=>x||0));
        }
        if(typeof data.turn === 'number') turn = data.turn;
        // synchronize firebasePlayer if not set (first arrival)
        // if host created and hasn't assigned players, assign guest as player 2 when joining (handled on join)
        undoUsed[turn] = false;
        // show delete button only to host (we detect host by createdAt? we set isHost on create)
        if(isHost){
          deleteBtn.style.display = 'inline-block';
        } else {
          deleteBtn.style.display = 'none';
        }
        render();
        connectionStatus.textContent = `æ¥ç¶š: ${room}ï¼ˆã‚ãªãŸã¯${firebasePlayer===1?'é»’':'ç™½'}ï¼‰`;
      });

      // store unsubscribe
      if(typeof unsub === 'function'){
        fbUnsubscribe = unsub;
      } else {
        // fallback: onValue returns function normally; if not, produce off wrapper
        fbUnsubscribe = () => { try { FB.off(FB.db, r); } catch(e) {} };
      }
    }

    async function createRoom(){
      onlineControls.style.display = 'block';
      let id = roomInput.value.trim() || Math.random().toString(36).slice(2,8);
      firebaseRoomId = id;
      roomInput.value = id;
      firebasePlayer = 1;
      isHost = true;
      // write initial board and mark players=1
      const roomRef = FB.ref(FB.db, 'rooms/' + id);
      const initial = initialBoard();
      await FB.set(roomRef, { board: initial, turn: 1, players: 1, createdAt: Date.now(), lastPass: null, finished: false });
      // show delete button for host
      deleteBtn.style.display = 'inline-block';
      listenRoom(id);
      connectionStatus.textContent = 'éƒ¨å±‹ä½œæˆ: ' + id + 'ï¼ˆé»’ï¼‰';
    }

    async function joinRoom(){
      const id = roomInput.value.trim();
      if(!id) return alert('éƒ¨å±‹IDã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
      const roomRef = FB.ref(FB.db, 'rooms/' + id);
      const snap = await FB.get(roomRef);
      if(!snap.exists()) return alert('ãã®éƒ¨å±‹ã¯å­˜åœ¨ã—ã¾ã›ã‚“');
      const data = snap.val();
      // mark as joined (increase players to 2)
      let players = data.players || 1;
      players = Math.min(2, players + 1);
      await FB.update(roomRef, { players });
      firebaseRoomId = id;
      roomInput.value = id;
      firebasePlayer = 2;
      isHost = false;
      deleteBtn.style.display = 'none';
      listenRoom(id);
      connectionStatus.textContent = 'éƒ¨å±‹å‚åŠ : ' + id + 'ï¼ˆç™½ï¼‰';
    }

    async function deleteRoom(){
      if(!firebaseRoomId || !isHost) return alert('ãƒ›ã‚¹ãƒˆã®ã¿å‰Šé™¤å¯èƒ½ã§ã™');
      if(!confirm('æœ¬å½“ã«éƒ¨å±‹ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿï¼ˆå…¨å“¡ãŒãƒ­ãƒ“ãƒ¼ã«æˆ»ã‚Šã¾ã™ï¼‰')) return;
      const roomRef = FB.ref(FB.db, 'rooms/' + firebaseRoomId);
      // set to null to delete
      await FB.set(roomRef, null);
      // local cleanup -> leaveRoomLocal(true) will be triggered by listener on clients, but host should also cleanup
      leaveRoomLocal(true);
      alert('éƒ¨å±‹ã‚’å‰Šé™¤ã—ã¾ã—ãŸ');
    }

    function leaveRoomLocal(toLocal = false){
      // detach listener
      if(fbUnsubscribe){
        try { fbUnsubscribe(); } catch(e) {}
        fbUnsubscribe = null;
      }
      // reset local firebase-related state
      firebaseRoomId = null;
      firebasePlayer = null;
      isHost = false;
      playersCountEl.textContent = '';
      connectionStatus.textContent = 'æœªæ¥ç¶š';
      deleteBtn.style.display = 'none';
      if(toLocal){
        modeSelect.value = 'local';
        cpuPanel.style.display = 'none';
        onlinePanel.style.display = 'none';
      }
      // reset board to initial
      init();
    }

    // when both passed or finished -> show result and reset
    function showGameEndAndReset(){
      const sc = countScores();
      let msg = `é»’ ${sc.b}æš ï¼ ç™½ ${sc.w}æš\n\n`;
      if(sc.b > sc.w) msg += 'ğŸŸ¤ é»’ã®å‹ã¡ï¼';
      else if(sc.w > sc.b) msg += 'âšª ç™½ã®å‹ã¡ï¼';
      else msg += 'ğŸ¤ å¼•ãåˆ†ã‘ï¼';
      alert(msg);
      // if host we can clear finished flag and reset DB board
      if(firebaseRoomId && isHost){
        const roomRef = FB.ref(FB.db, 'rooms/' + firebaseRoomId);
        const initial = initialBoard();
        FB.update(roomRef, { board: initial, turn: 1, lastPass: null, finished: false });
        // local reset
        init();
      } else {
        // non-host: just go local reset and leave room state as host chooses
        init();
      }
    }

    // utility: set room when host wants to push (used on reset)
    async function setRoomInitialIfHost(){
      if(!firebaseRoomId || !isHost) return;
      const roomRef = FB.ref(FB.db, 'rooms/' + firebaseRoomId);
      await FB.update(roomRef, { board: initialBoard(), turn: 1, lastPass: null, finished: false, players: 1 });
    }

    // initialize UI event wiring
    createBtn.onclick = createRoom;
    joinBtn.onclick = joinRoom;
    deleteBtn.onclick = deleteRoom;
    modeSelect.onchange = () => {
      // when mode changed, reset board (behavior requested)
      const newMode = modeSelect.value;
      cpuPanel.style.display = newMode === 'cpu' ? 'block' : 'none';
      onlinePanel.style.display = newMode === 'online' ? 'block' : 'none';
      // if switching away from online, detach listeners but keep room if host (not auto-delete)
      if(newMode !== 'online'){
        // leave firebase context but don't destroy room unless host explicitly deletes
        if(fbUnsubscribe){
          try { fbUnsubscribe(); } catch(e) {}
          fbUnsubscribe = null;
        }
        firebaseRoomId = null;
        firebasePlayer = null;
        connectionStatus.textContent = 'æœªæ¥ç¶š';
        playersCountEl.textContent = '';
        deleteBtn.style.display = 'none';
      }
      init();
      render();
    };
    onlineModeSel.onchange = ()=>{ onlineControls.style.display = onlineModeSel.value === 'off' ? 'none' : 'block'; };
    aiLevelSel.onchange = ()=> render();
    playerColorSel.onchange = ()=> render();

    // initial board setup
    function initialBoard(){
      const b = Array.from({length:SIZE}, ()=> Array(SIZE).fill(0));
      b[3][3]=2; b[3][4]=1; b[4][3]=1; b[4][4]=2;
      return b;
    }

    function init(){
      board = initialBoard();
      turn = 1;
      history = [];
      undoUsed = {1:false,2:false};
      saveState();
      render();
    }

    // start
    init();

  }); // DOMContentLoaded end
  </script>
</body>
</html>
