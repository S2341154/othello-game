<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>オセロ（Firebase対応・完全安定版）</title>
<link rel="icon" href="favicon.ico" />
  <style>
    :root{ --board-size: min(640px, 92vw); --bg:#0b3d2e; --control-w:320px; }
    body{ font-family: system-ui, -apple-system, "Hiragino Kaku Gothic ProN", "Noto Sans JP", "Segoe UI", Roboto, "Yu Gothic"; display:flex;gap:18px;align-items:flex-start;justify-content:center;padding:20px;background:#e9f0ed;color:#062; }
    .wrap{display:flex;gap:18px;align-items:flex-start;flex-wrap:wrap;justify-content:center;}
    .board{ width:var(--board-size);height:var(--board-size); background:linear-gradient(#0f523b,#0b3d2e); display:grid; grid-template-columns:repeat(8,1fr); grid-template-rows:repeat(8,1fr); gap:2px; padding:6px; border-radius:12px; box-shadow:0 6px 18px rgba(0,0,0,0.18); position:relative; }
    .cell{ background:var(--bg); border-radius:6px; position:relative; display:flex; align-items:center; justify-content:center; cursor:pointer; user-select:none; overflow:visible; }
    .cell:hover{ box-shadow:inset 0 0 0 2px rgba(255,255,255,0.03) }
    .disc{ width:84%; height:84%; border-radius:50%; box-shadow:inset 0 -6px 12px rgba(0,0,0,0.25); transition:transform 360ms ease; transform-style:preserve-3d; backface-visibility:hidden; }
    .disc.black{ background:linear-gradient(#222,#000) }
    .disc.white{ background:linear-gradient(#fff,#ddd) }
    .disc.flip{ transform:rotateY(180deg) }
    /* new placement animation */
    @keyframes placeDisc {
      0% { transform: scale(0.2); opacity: 0; }
      70% { transform: scale(1.08); opacity: 1; }
      100% { transform: scale(1); }
    }
    .disc.new { animation: placeDisc 280ms ease-out forwards; }

    .legal::after {
      content: '';
      position: absolute;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: rgba(255,255,255,0.9);
      opacity: 0.9;
      box-shadow: 0 1px 4px rgba(0,0,0,0.4);
      transition: transform 0.2s ease;
    }
    .cell.legal:hover::after { transform: scale(1.3); }

    .controls{ min-width:var(--control-w); display:flex; flex-direction:column; gap:10px; }
    .status{ background:#fff; padding:12px; border-radius:8px; box-shadow:0 6px 18px rgba(0,0,0,0.06); }
    .row{ display:flex; justify-content:space-between; gap:8px; align-items:center; }
    button{ padding:8px 12px; border-radius:8px; border:none; background:#0b7a59; color:#fff; font-weight:600; cursor:pointer; }
    button.secondary{ background:#5b5b5b; }
    select,input{ padding:8px; border-radius:6px; border:1px solid #ccc; }
    .small{ font-size:0.9rem; }
    footer{ font-size:0.8rem; color:#346; text-align:center; }
    @media (max-width:720px){ body{ flex-direction:column; align-items:center } .controls{ min-width:90vw } :root{ --board-size:90vw } }
    /* small badge for players count */
    #playersCount { display:inline-block; margin-left:8px; padding:2px 8px; background:#eee; color:#062; border-radius:12px; font-weight:700; font-size:0.85rem; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="board" id="board" aria-label="オセロの盤"></div>

    <div class="controls">
      <div class="status">
        <div class="row"><div>黒 (●)</div><div id="score-black">2</div></div>
        <div class="row"><div>白 (○)</div><div id="score-white">2</div></div>
        <hr/>
        <div class="row small"><div>現在の手番</div><div id="turn">黒</div></div>
        <div class="row small"><div>合法手数</div><div id="legal-count">4</div></div>
      </div>

      <div class="status">
        <div class="row"><div>モード</div>
          <select id="modeSelect">
            <option value="cpu">シングルプレイ（CPU）</option>
            <option value="local">ローカル2人対戦</option>
            <option value="online">オンライン対戦</option>
          </select>
        </div>

        <div id="cpuPanel" style="margin-top:8px">
          <div class="row small"><div>CPU強さ</div>
            <select id="aiLevel">
              <option value="0">初級（ランダム）</option>
              <option value="1" selected>中級（最大反転）</option>
              <option value="2">上級（2手読み）</option>
            </select>
          </div>
          <div class="row small" style="margin-top:6px"><div>あなたの色</div>
            <select id="playerColor"><option value="1" selected>黒（先手）</option><option value="2">白（後手）</option></select>
          </div>
        </div>

        <div id="onlinePanel" style="display:none;margin-top:10px">
          <div class="row small"><div>オンライン</div>
            <select id="onlineMode"><option value="off">オフ</option><option value="host">部屋を作る</option><option value="join">部屋に入る</option></select>
          </div>
          <div id="onlineControls" style="display:none;margin-top:8px">
            <div style="display:flex;gap:8px">
              <input id="roomId" placeholder="部屋ID（自動生成可）"/>
              <button id="createRoom">作成</button>
              <button id="joinRoom" class="secondary">参加</button>
              <button id="deleteRoomBtn" class="secondary" style="display:none">部屋削除</button>
            </div>
            <div style="margin-top:6px">
              <div class="small">Realtime DB を使います <span id="playersCount"></span></div>
              <small id="connectionStatus">未接続</small>
            </div>
          </div>
        </div>
      </div>

      <div style="display:flex;gap:8px;flex-wrap:wrap;justify-content:space-between">
        <button id="reset">リセット</button>
        <button id="undo" class="secondary">取り消し</button>
        <button id="pass" class="secondary">パス</button>
      </div>

      <div class="status small">
        <p>説明：各ターンごとに各プレイヤーは1回だけ取り消しできます（自分のターン内でのみ）。オンラインは Firebase Realtime Database を使用します。</p>
      </div>
    </div>
  </div>

  <footer>Firebase版 Othello（完全安定版）</footer>

  <script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-app.js";
  import { getDatabase, ref, set, get, onValue, off, update } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-database.js";

  // そのまま使う Firebase 設定（あなたが提示したもの）
  const firebaseConfig = {
    apiKey: "AIzaSyC8x4BmjNJlqMkCbs1xIi_OkNc2Hp3UWbY",
  authDomain: "othello-online-23943.firebaseapp.com",
  databaseURL: "https://othello-online-23943-default-rtdb.firebaseio.com",
  projectId: "othello-online-23943",
  storageBucket: "othello-online-23943.firebasestorage.app",
  messagingSenderId: "700231693409",
  appId: "1:700231693409:web:57c6b500271c80e4d2a620"
  };

  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);
  const FB = { db, ref, set, get, onValue, off, update };

  document.addEventListener("DOMContentLoaded", () => {
    const SIZE = 8;
    const DIRS = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];

    // game state
    let board = initialBoard();
    let turn = 1;
    let history = [];
    let busy = false;
    let undoUsed = {1:false,2:false};

    // firebase room state
    let firebaseRoomId = null;
    let firebasePlayer = null; // 1 or 2
    let isHost = false;
    let fbUnsubscribe = null;

    // UI
    const boardEl = document.getElementById("board");
    const scoreB = document.getElementById("score-black");
    const scoreW = document.getElementById("score-white");
    const turnEl = document.getElementById("turn");
    const legalCountEl = document.getElementById("legal-count");
    const modeSelect = document.getElementById("modeSelect");
    const cpuPanel = document.getElementById("cpuPanel");
    const aiLevelSel = document.getElementById("aiLevel");
    const playerColorSel = document.getElementById("playerColor");
    const onlinePanel = document.getElementById("onlinePanel");
    const onlineModeSel = document.getElementById("onlineMode");
    const onlineControls = document.getElementById("onlineControls");
    const roomInput = document.getElementById("roomId");
    const createBtn = document.getElementById("createRoom");
    const joinBtn = document.getElementById("joinRoom");
    const deleteBtn = document.getElementById("deleteRoomBtn");
    const connectionStatus = document.getElementById("connectionStatus");
    const playersCountEl = document.getElementById("playersCount");
    const resetBtn = document.getElementById("reset");
    const undoBtn = document.getElementById("undo");
    const passBtn = document.getElementById("pass");

    // helpers
    function cloneBoard(b){ return b.map(r=>[...r]); }
    function inside(r,c){ return r>=0 && r<SIZE && c>=0 && c<SIZE; }
    function countScores(b=board){ let bC=0,wC=0; for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++){ if(b[r][c]===1) bC++; else if(b[r][c]===2) wC++; } return {b:bC,w:wC}; }
    function saveState(){ history.push({board:cloneBoard(board),turn}); if(history.length>256) history.shift(); updateUndo(); }
    function updateUndo(){ undoBtn.disabled = (modeSelect.value==="online") || history.length<2 || busy || undoUsed[turn]; }
    function legalMovesFor(p, b=board){
      const opp = p===1?2:1;
      const moves = [];
      for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++){
        if(b[r][c]!==0) continue;
        for(const [dr,dc] of DIRS){
          let rr=r+dr, cc=c+dc, found=false;
          while(inside(rr,cc) && b[rr][cc]===opp){ rr+=dr; cc+=dc; found=true; }
          if(found && inside(rr,cc) && b[rr][cc]===p){ moves.push([r,c]); break; }
        }
      }
      return moves;
    }
    function applyMove(p,r,c,b=board){
      const opp = p===1?2:1;
      if(b[r][c]!==0) return [];
      b[r][c]=p;
      const flipped = [];
      for(const [dr,dc] of DIRS){
        let rr=r+dr, cc=c+dc, path=[];
        while(inside(rr,cc) && b[rr][cc]===opp){ path.push([rr,cc]); rr+=dr; cc+=dc; }
        if(path.length && inside(rr,cc) && b[rr][cc]===p){
          for(const [fr,fc] of path){ b[fr][fc]=p; flipped.push([fr,fc]); }
        }
      }
      return flipped;
    }

    // rendering (keeps look same as before)
    function render(){
      boardEl.innerHTML = '';
      const legal = legalMovesFor(turn);
      const mode = modeSelect.value;
      const isOnline = mode === 'online';
      const isMyTurn = !isOnline || (firebasePlayer === turn);

      // build grid
      for(let r=0;r<SIZE;r++){
        for(let c=0;c<SIZE;c++){
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.dataset.r = r;
          cell.dataset.c = c;

          if(board[r][c] !== 0){
            const d = document.createElement('div');
            d.className = 'disc ' + (board[r][c]===1 ? 'black' : 'white');
            cell.appendChild(d);
          } else {
            // show legal only if local/cpu OR online & myTurn
            if(legal.some(x=>x[0]===r && x[1]===c)){
              if(!isOnline || isMyTurn) cell.classList.add('legal');
            }
          }
          boardEl.appendChild(cell);
        }
      }

      const sc = countScores();
      scoreB.textContent = sc.b;
      scoreW.textContent = sc.w;
      turnEl.textContent = turn===1 ? '黒' : '白';
      legalCountEl.textContent = legal.length;

      // board dimming for online
      if(isOnline){
        boardEl.style.opacity = isMyTurn ? '1' : '0.5';
      } else {
        boardEl.style.opacity = '1';
      }

      // pass button enabled only when no legal moves
      passBtn.disabled = (legal.length > 0) || busy;

      updateUndo();
      // expose few for debugging if needed
      window.turn = turn;
      window.firebasePlayer = firebasePlayer;
    }

    // click handling
    boardEl.addEventListener('click', e=>{
      const cell = e.target.closest('.cell');
      if(!cell || busy) return;
      const r = +cell.dataset.r, c = +cell.dataset.c;
      const mode = modeSelect.value;

      if(mode === 'cpu' || mode === 'local'){
        const legal = legalMovesFor(turn);
        if(!legal.some(x=>x[0]===r && x[1]===c)) return;
        saveState();
        applyMove(turn, r, c);
        // mark new disc for animation: add class new to that disc element after render
        // but we use render to re-create DOM; we can add new class by comparing history last -> handled below by saving state and checking
        turn = 3 - turn;
        undoUsed[turn] = false;
        saveState();
        render();
        if(mode === 'cpu' && turn !== +playerColorSel.value){
          // CPU move schedule: ensure only one scheduled at a time
          setTimeout(doCpu, 300);
        }
      } else if(mode === 'online'){
        if(!firebaseRoomId){ alert('オンライン未接続'); return; }
        if(firebasePlayer !== turn){ alert('あなたの手番ではありません'); return; }
        const legal = legalMovesFor(turn);
        if(!legal.some(x=>x[0]===r && x[1]===c)) return;
        // optimistic local apply (but we will sync to DB)
        saveState();
        applyMove(turn, r, c);
        // advance turn locally while syncing DB (DB authoritative will update all clients)
        const nextTurn = 3 - turn;
        // update DB with board and nextTurn, clear lastPass
        setRoomFirebase(firebaseRoomId, board, nextTurn, { lastPass: null });
      }
    });

    // reset / undo / pass
    resetBtn.addEventListener('click', ()=>{
      if(!confirm('リセットしますか？')) return;
      init();
      if(firebaseRoomId && isHost){
        // host should write initial board to DB
        setRoomFirebase(firebaseRoomId, board, 1, { lastPass: null, players: 1 });
      } else if(firebaseRoomId && !isHost){
        // guest: don't overwrite host DB
      }
    });

    undoBtn.addEventListener('click', ()=>{
      if(busy) return;
      if(modeSelect.value === 'online') return;
      if(history.length < 2) return;
      if(undoUsed[turn]) return;
      // pop last (current state), then restore previous
      history.pop();
      const last = history.pop();
      board = cloneBoard(last.board);
      turn = last.turn;
      undoUsed[turn] = true;
      saveState();
      render();
    });

    passBtn.addEventListener('click', async ()=>{
      if(busy) return;
      const legal = legalMovesFor(turn);
      if(legal.length > 0) return; // cannot pass if you have legal moves

      const mode = modeSelect.value;
      if(mode === 'online'){
        if(!firebaseRoomId) return alert('オンライン未接続');
        if(firebasePlayer !== turn) return alert('あなたの手番ではありません');
        // set lastPass to current player in DB; if lastPass already other player => both passed => end game
        const roomRef = FB.ref(FB.db, 'rooms/' + firebaseRoomId);
        try {
          // read current data
          const snap = await FB.get(roomRef);
          const data = snap.exists() ? snap.val() : null;
          const prevLastPass = data && data.lastPass ? data.lastPass : null;
          if(prevLastPass && prevLastPass !== firebasePlayer){
            // both passed -> end game
            // leave final board in DB and set finished flag
            await FB.update(roomRef, { lastPass: firebasePlayer, finished: true });
            // show result locally
            setTimeout(()=>{ showGameEndAndReset(); }, 200);
          } else {
            // set lastPass to this player and advance turn
            const nextTurn = 3 - turn;
            await FB.update(roomRef, { lastPass: firebasePlayer, board: board, turn: nextTurn });
          }
        } catch(err){
          console.error('pass error', err);
        }
      } else {
        // offline pass
        turn = 3 - turn;
        undoUsed[turn] = false;
        saveState();
        render();
      }
    });

    // CPU
    function ai_random(p){ const m = legalMovesFor(p); return m.length ? m[Math.floor(Math.random()*m.length)] : null; }
    function ai_maxflip(p){ const m = legalMovesFor(p); let best=null, max=-1; for(const [r,c] of m){ const b = cloneBoard(board); const f = applyMove(p,r,c,b); if(f.length>max){ max=f.length; best=[r,c]; } } return best; }
    function ai_minimax(p){ return ai_maxflip(p); } // simplified

    function doCpu(){
      if(busy) return;
      if(modeSelect.value !== 'cpu') return;
      const cpu = (+playerColorSel.value === 1) ? 2 : 1;
      if(turn !== cpu) return;
      busy = true;
      setTimeout(()=>{
        const lvl = +aiLevelSel.value;
        let mv = null;
        if(lvl === 0) mv = ai_random(cpu);
        else if(lvl === 1) mv = ai_maxflip(cpu);
        else mv = ai_minimax(cpu);
        if(!mv){
          // pass
          turn = 3 - turn;
          undoUsed[turn] = false;
          saveState();
          busy = false;
          render();
          return;
        }
        saveState();
        applyMove(cpu, mv[0], mv[1]);
        turn = 3 - turn;
        undoUsed[turn] = false;
        saveState();
        busy = false;
        render();
      }, 380);
    }

    // Firebase: helper to set room data atomically-ish
    async function setRoomFirebase(room, b, t, extra = {}){
      const r = FB.ref(FB.db, 'rooms/' + room);
      const payload = Object.assign({}, { board: b, turn: t }, extra);
      try {
        await FB.update(r, payload);
      } catch(e){
        console.error('setRoomFirebase error', e);
      }
    }

    // send move (online) -- uses DB update, DB listener will push to other clients
    async function sendMoveFirebase(room, p, rpos, cpos){
      if(busy) return;
      busy = true;
      // validate legal on server copy is omitted (simple implementation)
      // apply locally first for responsiveness
      applyMove(p, rpos, cpos);
      const nextTurn = 3 - p;
      try {
        await setRoomFirebase(room, board, nextTurn, { lastPass: null });
      } catch(e){
        console.error('sendMoveFirebase error', e);
      } finally {
        busy = false;
      }
    }

    // listen to room: register onValue, manage unsubscribe
    function listenRoom(room){
      // detach previous
      if(fbUnsubscribe){
        try { fbUnsubscribe(); } catch(e) {}
        fbUnsubscribe = null;
      }
      const r = FB.ref(FB.db, 'rooms/' + room);

      // subscribe
      const unsub = FB.onValue(r, (snap)=>{
        const data = snap.exists() ? snap.val() : null;
        if(!data){
          // room removed -> exit to local
          alert('ホストが部屋を削除しました。ローカル対戦に戻ります。');
          leaveRoomLocal(true);
          return;
        }
        // update players count display
        const players = data.players || 1;
        playersCountEl.textContent = `(${players}/2)`;

        // if finished flag set -> show result once then reset room locally (do not delete DB)
        if(data.finished){
          // copy board & show result
          if(Array.isArray(data.board)) board = data.board.map(row=>row.map(x=>x||0));
          render();
          setTimeout(()=>{ showGameEndAndReset(); }, 200);
          return;
        }

        // normal update: apply board & turn
        if(Array.isArray(data.board)){
          board = data.board.map(row=>row.map(x=>x||0));
        }
        if(typeof data.turn === 'number') turn = data.turn;
        // synchronize firebasePlayer if not set (first arrival)
        // if host created and hasn't assigned players, assign guest as player 2 when joining (handled on join)
        undoUsed[turn] = false;
        // show delete button only to host (we detect host by createdAt? we set isHost on create)
        if(isHost){
          deleteBtn.style.display = 'inline-block';
        } else {
          deleteBtn.style.display = 'none';
        }
        render();
        connectionStatus.textContent = `接続: ${room}（あなたは${firebasePlayer===1?'黒':'白'}）`;
      });

      // store unsubscribe
      if(typeof unsub === 'function'){
        fbUnsubscribe = unsub;
      } else {
        // fallback: onValue returns function normally; if not, produce off wrapper
        fbUnsubscribe = () => { try { FB.off(FB.db, r); } catch(e) {} };
      }
    }

    async function createRoom(){
      onlineControls.style.display = 'block';
      let id = roomInput.value.trim() || Math.random().toString(36).slice(2,8);
      firebaseRoomId = id;
      roomInput.value = id;
      firebasePlayer = 1;
      isHost = true;
      // write initial board and mark players=1
      const roomRef = FB.ref(FB.db, 'rooms/' + id);
      const initial = initialBoard();
      await FB.set(roomRef, { board: initial, turn: 1, players: 1, createdAt: Date.now(), lastPass: null, finished: false });
      // show delete button for host
      deleteBtn.style.display = 'inline-block';
      listenRoom(id);
      connectionStatus.textContent = '部屋作成: ' + id + '（黒）';
    }

    async function joinRoom(){
      const id = roomInput.value.trim();
      if(!id) return alert('部屋IDを入力してください');
      const roomRef = FB.ref(FB.db, 'rooms/' + id);
      const snap = await FB.get(roomRef);
      if(!snap.exists()) return alert('その部屋は存在しません');
      const data = snap.val();
      // mark as joined (increase players to 2)
      let players = data.players || 1;
      players = Math.min(2, players + 1);
      await FB.update(roomRef, { players });
      firebaseRoomId = id;
      roomInput.value = id;
      firebasePlayer = 2;
      isHost = false;
      deleteBtn.style.display = 'none';
      listenRoom(id);
      connectionStatus.textContent = '部屋参加: ' + id + '（白）';
    }

    async function deleteRoom(){
      if(!firebaseRoomId || !isHost) return alert('ホストのみ削除可能です');
      if(!confirm('本当に部屋を削除しますか？（全員がロビーに戻ります）')) return;
      const roomRef = FB.ref(FB.db, 'rooms/' + firebaseRoomId);
      // set to null to delete
      await FB.set(roomRef, null);
      // local cleanup -> leaveRoomLocal(true) will be triggered by listener on clients, but host should also cleanup
      leaveRoomLocal(true);
      alert('部屋を削除しました');
    }

    function leaveRoomLocal(toLocal = false){
      // detach listener
      if(fbUnsubscribe){
        try { fbUnsubscribe(); } catch(e) {}
        fbUnsubscribe = null;
      }
      // reset local firebase-related state
      firebaseRoomId = null;
      firebasePlayer = null;
      isHost = false;
      playersCountEl.textContent = '';
      connectionStatus.textContent = '未接続';
      deleteBtn.style.display = 'none';
      if(toLocal){
        modeSelect.value = 'local';
        cpuPanel.style.display = 'none';
        onlinePanel.style.display = 'none';
      }
      // reset board to initial
      init();
    }

    // when both passed or finished -> show result and reset
    function showGameEndAndReset(){
      const sc = countScores();
      let msg = `黒 ${sc.b}枚 ／ 白 ${sc.w}枚\n\n`;
      if(sc.b > sc.w) msg += '🟤 黒の勝ち！';
      else if(sc.w > sc.b) msg += '⚪ 白の勝ち！';
      else msg += '🤝 引き分け！';
      alert(msg);
      // if host we can clear finished flag and reset DB board
      if(firebaseRoomId && isHost){
        const roomRef = FB.ref(FB.db, 'rooms/' + firebaseRoomId);
        const initial = initialBoard();
        FB.update(roomRef, { board: initial, turn: 1, lastPass: null, finished: false });
        // local reset
        init();
      } else {
        // non-host: just go local reset and leave room state as host chooses
        init();
      }
    }

    // utility: set room when host wants to push (used on reset)
    async function setRoomInitialIfHost(){
      if(!firebaseRoomId || !isHost) return;
      const roomRef = FB.ref(FB.db, 'rooms/' + firebaseRoomId);
      await FB.update(roomRef, { board: initialBoard(), turn: 1, lastPass: null, finished: false, players: 1 });
    }

    // initialize UI event wiring
    createBtn.onclick = createRoom;
    joinBtn.onclick = joinRoom;
    deleteBtn.onclick = deleteRoom;
    modeSelect.onchange = () => {
      // when mode changed, reset board (behavior requested)
      const newMode = modeSelect.value;
      cpuPanel.style.display = newMode === 'cpu' ? 'block' : 'none';
      onlinePanel.style.display = newMode === 'online' ? 'block' : 'none';
      // if switching away from online, detach listeners but keep room if host (not auto-delete)
      if(newMode !== 'online'){
        // leave firebase context but don't destroy room unless host explicitly deletes
        if(fbUnsubscribe){
          try { fbUnsubscribe(); } catch(e) {}
          fbUnsubscribe = null;
        }
        firebaseRoomId = null;
        firebasePlayer = null;
        connectionStatus.textContent = '未接続';
        playersCountEl.textContent = '';
        deleteBtn.style.display = 'none';
      }
      init();
      render();
    };
    onlineModeSel.onchange = ()=>{ onlineControls.style.display = onlineModeSel.value === 'off' ? 'none' : 'block'; };
    aiLevelSel.onchange = ()=> render();
    playerColorSel.onchange = ()=> render();

    // initial board setup
    function initialBoard(){
      const b = Array.from({length:SIZE}, ()=> Array(SIZE).fill(0));
      b[3][3]=2; b[3][4]=1; b[4][3]=1; b[4][4]=2;
      return b;
    }

    function init(){
      board = initialBoard();
      turn = 1;
      history = [];
      undoUsed = {1:false,2:false};
      saveState();
      render();
    }

    // start
    init();

  }); // DOMContentLoaded end
  </script>
</body>
</html>
